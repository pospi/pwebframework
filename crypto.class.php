<?php
/**
 * Encryption methods
 *
 * Contains methods for:
 * - encoding and decoding GPG encrypted files
 * - managing two-way AES encryption of string values
 * - one-way string hashing
 *
 * @package	pWebFramework
 * @author	Sam Pospischil <pospi@spadgos.com>
 * @since	24/7/12
 * @requires mcrypt to be installed for two-way AES encryption methods
 * @requires Gnu GPG to be installed for file-based GPG encryption methods
 * @requires at least a blowfish hashing implementation for hashing methods, but preferrably SHA-512.
 * @requires processlogger.class.php if logging is enabled
 */
class Crypto
{
	const CRYPT_ALPHABET = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';	// alphabet generated by calls to crypt()

	public static $GPG_PATH = '/usr/bin/gpg';
	public static $GPG_DATADIR = null;	// defaults to ~/.gnupg

	private static $logger;				// ProcessLogger instance used for logging
	private static $debugLog = false;	// if true, output extra info to log

	/**
	 * Detect the paths to executables required by this class
	 */
	public static function detectGPGPath()
	{
		$path = trim(`which gpg`);
		if ($path) {
			self::$GPG_PATH = $path;
		} else {
			self::log("Unable to determine GPG path (is GPG installed?)");
		}
	}

	/**
	 * Enable error logging via a ProcessLogger instance.
	 * @param  ProcessLogger $log logger instance to perform error & debug logging through
	 */
	public static function enableLogging(ProcessLogger $log, $debug = false)
	{
		self::$debugLog = $debug;
		self::$logger = $log;
	}

	private static function log($line, $debug = false)
	{
		if ($debug && !self::$debugLog) {
			return false;
		}
		if (self::$logger) {
			self::$logger[] = $line;
		} else {
			trigger_error($line, E_USER_WARNING);
		}
	}

	//--------------------------------------------------------------------------
	// Two-way GPG encryption

	/**
	 * Encrypt a string for a recipient in your GPG keyring
	 * @param  string $string         string to encrypt
	 * @param  string $recipientEmail GPG key uid
	 * @param  string $outputFile     file to save the result to, if any
	 * @return the encrypted data as hex, or boolean flag if outputting to a file
	 */
	public static function encryptString($string, $recipientEmail, $outputFile = null)
	{
		$string = escapeshellarg($string);
		$recipientEmail = escapeshellarg($recipientEmail);
		$outputFile = isset($outputFile) ? escapeshellarg($outputFile) : false;

		if ($outputFile) {
			$cmd = "echo $string | " . self::$GPG_PATH . (self::$GPG_DATADIR ? ' --homedir ' . escapeshellarg(self::$GPG_DATADIR) : '') . " --always-trust --yes -e -r $recipientEmail -o $outputFile";
			self::log("RUNNING ENCRYPTION: " . $cmd, true);

			return self::exec($cmd);
		}

		$cmd = "echo $string | " . self::$GPG_PATH . (self::$GPG_DATADIR ? ' --homedir ' . escapeshellarg(self::$GPG_DATADIR) : '') . " --always-trust --yes -e -r $recipientEmail";
		self::log("RUNNING ENCRYPTION: " . $cmd, true);

		return bin2hex(shell_exec($cmd));
	}

	/**
	 * Encrypt a file
	 * @param  string $file           file to encrypt
	 * @param  string $recipientEmail GPG key uid
	 * @param  bool   $targetFilename if false, will output as the source filename suffixed with '.gpg'. If true, replaces the original file. Otherwise output to this file.
	 * @return the filename of the resulting encrypted file
	 */
	public static function encryptFile($file, $recipientEmail, $targetFilename = false)
	{
		$recipientEmail = escapeshellarg($recipientEmail);
		$replaceOriginal = $targetFilename === true;

		$cmd = self::$GPG_PATH . (self::$GPG_DATADIR ? ' --homedir ' . escapeshellarg(self::$GPG_DATADIR) : '') . " --always-trust --yes --status-fd 1 -e -r $recipientEmail" . (!$replaceOriginal && $targetFilename ? " -o $targetFilename" : '') . " " . escapeshellarg($file);
		self::log("RUNNING ENCRYPTION: " . $cmd, true);

		if (self::exec($cmd) === 0) {
			if ($replaceOriginal) {
				unlink($file);
				rename($file . '.gpg', $file);
				return $file;
			}
			return $file . '.gpg';
		}
		return false;
	}

	/**
	 * Decrypt a file encrypted using a GPG key
	 * @param  string $file            file to decrypt
	 * @param  string $keyPassphrase   passphrase for the GPG key
	 * @param  string $unencryptedFile destination file to write unencrypted contents to. If ommitted, the unencrypted data is returned.
	 * @return the decrypted file contents if $unencryptedFile is ommitted, otherwise a bool to indicate the success of the command.
	 */
	public static function decryptFile($file, $keyPassphrase = null, $unencryptedFile = null)
	{
		$file = escapeshellarg($file);
		$unencryptedFile = isset($unencryptedFile) ? escapeshellarg($unencryptedFile) : false;
		$keyPassphrase = isset($keyPassphrase) ? escapeshellarg($keyPassphrase) : false;

		if ($keyPassphrase) {
			$cmd = ' | ' . self::$GPG_PATH . (self::$GPG_DATADIR ? ' --homedir ' . escapeshellarg(self::$GPG_DATADIR) : '') . " --always-trust --yes --passphrase-fd 0 --status-fd 1 " . ($unencryptedFile ? "-o $unencryptedFile " : '') . "-d $file";
			$logCmd = "echo '[PASSPHRASE]'" . $cmd;
			$cmd = "echo {$keyPassphrase}" . $cmd;
		} else {
			$cmd = self::$GPG_PATH . (self::$GPG_DATADIR ? ' --homedir ' . escapeshellarg(self::$GPG_DATADIR) : '') . " --always-trust --yes " . ($unencryptedFile ? "-o $unencryptedFile " : '') . "-d $file";
			$logCmd = $cmd;
		}

		self::log("RUNNING DECRYPTION: " . $logCmd, true);

		if ($unencryptedFile) {
			$res = self::exec($cmd);
		} else {
			$res = shell_exec($cmd);
		}

		return $unencryptedFile ? $res === 0 : $res;
	}

	//--------------------------------------------------------------------------
	//	Two-way AES encryption

	/**
	 * Encrypt a string using 256-bit AES encryption
	 * @param  string $text          text to encrypt
	 * @param  string $encryptionKey (salted) key for the encryption
	 * @return the encrypted string as hex, with input seed value prepended
	 */
	public static function encryptAES($text, $encryptionKey)
	{
		$td = mcrypt_module_open(MCRYPT_RIJNDAEL_256, '', MCRYPT_MODE_CBC, '');
		$iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($td), MCRYPT_RAND);

		$encryptionKey = substr($encryptionKey, 0, mcrypt_enc_get_key_size($td));

		mcrypt_generic_init($td, $encryptionKey, $iv);

		$encrypted_data = mcrypt_generic($td, $text);

		mcrypt_generic_deinit($td);
		mcrypt_module_close($td);

		return bin2hex($iv . $encrypted_data);
	}

	/**
	 * Decrypts a string encrypted using AES 256-bit encryption with the same key
	 * @param  string $encryptedString encrypted string returned from encryptAES()
	 * @param  string $encryptionKey   (salted) encryption key for decoding the string
	 * @return the decrypted string
	 */
	public static function decryptAES($encryptedString, $encryptionKey)
	{
		$td = mcrypt_module_open(MCRYPT_RIJNDAEL_256, '', MCRYPT_MODE_CBC, '');
		$ivSize = mcrypt_enc_get_iv_size($td);

		$encryptedString = self::hex2bin($encryptedString);
		$iv = substr($encryptedString, 0, $ivSize);
		$encryptedString = substr($encryptedString, $ivSize);

		$encryptionKey = substr($encryptionKey, 0, mcrypt_enc_get_key_size($td));

		mcrypt_generic_init($td, $encryptionKey, $iv);

		$decrypted_data = mdecrypt_generic($td, $encryptedString);

		mcrypt_generic_deinit($td);
		mcrypt_module_close($td);

		return $decrypted_data;
	}

	//--------------------------------------------------------------------------
	//	One-way hashing, using SHA-512 (preferred), SHA-256 or Blowfish

	/**
	 * Hash a string with a provided salt
	 * @param  string $string string to hash
	 * @param  string $salt   salt to hash with
	 * @return hashed string as hex
	 */
	public static function hash($string, $salt)
	{
		if (defined('CRYPT_SHA512') && CRYPT_SHA512) {
			$salt = '$6$rounds=5000$' . $salt . '$';
		} else if (defined('CRYPT_SHA256') && CRYPT_SHA256) {
			$salt = '$5$rounds=5000$' . $salt . '$';
		} else if (defined('CRYPT_BLOWFISH') && CRYPT_BLOWFISH) {
			$salt = '$2a$08$' . preg_replace('/[^a-zA-Z0-9]/', '-', $salt) . '$';
		}

		$result = crypt($string, $salt);
		$result = substr($result, strrpos($result, '$') + 1);

		return self::base64toHex($result);
	}

	//--------------------------------------------------------------------------

	/**
	 * Decodes a base64 string generated by crypt() into a hex string
	 * @param  string $str crypt() hash
	 * @return hex string suitable for integer casting or DB insertion (prefix with 0x)
	 */
	private static function base64toHex($str)
	{
	    // set up the array to feed numerical data using characters as keys
	    $alpha = array_flip(str_split(self::CRYPT_ALPHABET));
	    // split the input into single-character (6 bit) chunks
	    $bitArray = str_split($str);
	    $decodedStr = '';
	    foreach ($bitArray as &$bits) {
	        if ($bits == '$') { // $ indicates the end of the string, to stop processing here
	            break;
	        }
	        if (!isset($alpha[$bits])) { // if we encounter a character not in the alphabet
	            return false;            // then break execution, the string is invalid
	        }
	        // decbin will only return significant digits, so use sprintf to pad to 6 bits
	        $decodedStr .= sprintf('%06s', decbin($alpha[$bits]));
	    }
	    // there can be up to 6 unused bits at the end of a string, so discard them
	    $decodedStr = substr($decodedStr, 0, strlen($decodedStr) - (strlen($decodedStr) % 8));
	    $byteArray = str_split($decodedStr, 8);
	    foreach ($byteArray as &$byte) {
	        $byte = chr(bindec($byte));
	    }
	    return bin2hex(join($byteArray));
	}

	public static function hex2bin($str)
	{
		if (function_exists('hex2bin')) {
			return hex2bin($str);
		}
		return pack("H*" , $str);
	}

	/**
	 * execute a command and return exit code. Suppress all output from the command.
	 */
	private static function exec($cmd)
	{
		$null = array();
		unset($null);
		exec($cmd, $null, $exitStatus);

		if ($exitStatus !== 0) {
			self::log("Command error (exit status {$exitStatus})");
			$cmdOutput = implode("\n", $null);
			if ($cmdOutput) {
				self::log($cmdOutput);
			} else {
				self::log("No error output available");
			}
		}

		return $exitStatus;
	}
}
